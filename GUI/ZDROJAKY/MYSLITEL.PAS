unit Myslitel;
{$DEFINE JENBRANI}

interface

uses coty;

type
  TStyl = (Nulovy, Normalni, OnDopredu, JaDopredu);
  { Nulovy     - ádné vıpisy
    Normalni   - myslím na svùj tah
    OnDopredu  - odhaduji soupeøùv tah pøi myšlení dopøedu
    JaDopredu  - poèítám svou odpovìï na oèekávanı soupeøùv tah pøi myšlení
    dopøedu
  }
  TAkce = procedure;
  TDejtahProc = procedure(t1: ttah1);
  THodnotyTahu = array [1 .. maxtah] of longint;
  THloubkyTahu = array [1 .. maxtah] of byte;

  TMeziData = record
    Alfa, Beta: longint;
    { Alfa a Beta PØED poèítáním prvního nedopoèteného tahu;
      Cena je hodnota posledního zlepšujícího tahu }
    Hloubka, I, Platnych: Integer;
    { Poslední nedopoètená hloubka; První nedopoètenı tah v Hloubce,
      Poèet tahù, pro nì má smysl Hodnoty }
    Dojeto: Boolean;
    Pozice: TPozice;
    { Pozice, k ní vede tah uivatele, na kterı se pøipravuji }
    Tahy: TTahy; { Všechny tahy z pozice, dosavadní nejlepší je první,
      prvních Platnych je setøídìno podle vıhodnosti. }
    Hodnoty: array [1 .. maxtah] of longint;
  end;

  PMeziSeznam = ^TMeziSeznam;

  TMeziSeznam = record
    Data: TMeziData;
    n: PMeziSeznam;
  end;

  PMezivypocet = ^TMezivypocet;

  TMezivypocet = class
  public
    Seznam: PMeziSeznam;
    procedure Pridej(var Data: TMeziData); { Inteligentnì pøidá do Seznamu
      Inteligentnì znamená: Nejsou-li tam, pøidá je
      Jsou-li tam do menší hloubky, pøepíše jimi ten údaj
      Jsou-li tam do stejné nebo vìtší hloubky, neudìlá nic }
    procedure DejInfo(var Pozice: TPozice; var AlgCfg: TAlgCfg;
      var Data: TMeziData);
    { Inteligentnì najde v Seznamu informace o Pozici.
      Inteligentnì znamená, e pokud tam nejsou, tak rozumnì doplní údaje sám.
      Hloubka a I budou 0, tahy budou platné tahy a Cena hodnota Pozice }
    procedure SmazSeznam;
    destructor Destroy; override;
  end;

  TMyslitel = class
  private
    VolanoMusimKoncit: word; { Abych mìl kontrolu nad èasem v dobì vıpoètu,
      volám metodu MusimKoncit:boolean. Ta otestuje èas a jednou za n volání
      pøedá øízení Woknùm, aby mohly distribuovat èekající zprávy.
      Ve VolanoMusimKoncit je poèet tìch volání. Mùe obèas pøetéct, ale to
      vùbec nevadí. }
    KoncovyCas: longint; { Èas, kdy musím ukonèit vıpoèet a táhnout. }
    Ukoncit: Boolean; { Vyprší-li èas, vynutí-li si uivatel tah nebo myslím-li
      dopøedu a v dùsledku uivatelova tahu se zaavolá PrestanDopredu }
    AkceKonecDopredu: TAkce; { Co mám pøi ukonèení myšlení dopøedu udìlat,
      pointer naproceduru bez parametrù. Je-li nil, nevolá se (tj. ádná akce).
      Vıznam: Chci udìlat nìco, kvùli èemu je tøeba pøestat myslet dopøedu
      napø. ukonèit program nebo pøemıšlet normálnì. Myšlení dopøedu
      ale nejde jen tak z procedury zastavit. Je tøeba zavolat
      PrestanDopredu, to nastaví Ukoncit na true a a se zpracují ve
      Windows všechny zprávy, dostane se k lízu myšlení dopøedu a samo
      se ukonèí (nebo Ukoncit=true). Jako poslední akci zavolá tuto
      proceduru, která vykoná to, co se pùvodnì mìlo udìlat. }
    Partie: PJednoPartie;
    { musím si pamatovat kus historie, kvùli pravidlu 50 tahù
      a pravidlu opakování pozic (a abych tøeba vùbec poznal vìènı šach).
      Sem si pøekopíruji potøebnou èást partie z objektu šachovnice pøi kadém
      volání myslící procedury (DejTah nebo MysliOTahDopredu). }
    Pozice: TPozice; { Sem si pøekopíruji pozici z objektu šachovnice
      pøi kadém volání myslící procedury (DejTah nebo MysliOTahDopredu). }
    MeziVypocet: TMezivypocet; { Sem si uloím vısledky MysliOTahDopredu.
      Musí bıt nil, pokud jsem nic nevypoèítal !!!! Není-li nil, dealokuje se.
      Pouije se v DejTah a to pokud platí a) i b)
      a) MeziVypocet <> nil
      b) Pozice "=" nPozice (napø. uivatel mohl zmìnit pozici) }
    Hraji: TDejtahProc; { Tuhle procedure zavolám kdy táhnu. Tato procedura by
      mìla jen poslat zprávu na okno, v LParam bude zakódovanı tah. }
    function Transformuj(co: longint): longint;
    { Pøevede hodnotu pozice tak aby z n. pùltahem mat bylo (n+1). pùltahem
      mat. Jinak by algoritmus nepreferoval vdy nejkratší cestu k vítìzství. }
    function MusimKoncit: Boolean;
    function Alfa_Beta(Alfa, Beta: longint; Hloubka: Integer;
      var Dojeto: Boolean; HloubkaRekurze: Integer; Styl: TStyl;
      var pocitam, Nejlepsi: ShortString): longint;
    { Alfa-beta metoda do zadané hloubky s dopoètem do tiché pozice
      s kaskádovitım prùchodem a se zapamatováváním hodnot tahù vypoètenıch a
      do konce. }
    function Alfa_Beta_Vrazi(Alfa, Beta: longint; Hloubka: Integer;
      var Dojeto: Boolean; HloubkaRekurze: Integer; Styl: TStyl): longint;
    { Dopoèet do tiché pozice, nejvıše však do zadané hloubky. Alfa-beta metoda
      s kaskádovitım prùchodem a se zapamatováváním hodnot tahù vypoètenıch a
      do tichého konce. }
    Procedure globBIterace(var MeziData: TMeziData; HorsiTahy: longint;
      Styl: TStyl; var pocitam, Nejlepsi: ShortString);
    Procedure globCIterace(var MeziData: TMeziData; HorsiTahy: longint;
      Styl: TStyl; var pocitam, Nejlepsi: ShortString);
    Procedure VypisVariantu(Tah1: ttah1; Var pocitam: ShortString; PocPos: byte;
      Styl: TStyl; Hloubka: Integer);
    Procedure VypisNejlepsi(Tah1: ttah1; Var Nejlepsi: ShortString;
      Styl: TStyl);
  public
    MyslimDopredu, Myslim: Boolean; { Stav }
    CasNaTah: longint;
    AlgCfg: TAlgCfg; { Konfigurace algoritmu. }
    constructor Create(nHraji: TDejtahProc);
    destructor Destroy; override;
    procedure DejTah(var npozice: TPozice; var npartie: ppartie);
    { Pøekopíruje si parametry, pøemıšlí. A uplyne èas nebo je zavoláno
      HrajTed, zavolá Hraji(nejlepší tah) a hned potom se ukonèí.
    }
    procedure HrajTed;
    { Jen nastaví private promìnné a procedura konèí. V dùsledku nastavení
      promìnnıch objekt okamitì táhne (je-li na tahu). }
    procedure MysliOTahDopredu(var npozice: TPozice; npartie: ppartie);
    { Dealokuje MeziVypocet (není-li nil) a znovu vytvoøí.
      Musí bıt explicitnì zastaveno následující metodou. V nìkterıch pøípadech
      se ale ukonèí sama (pokud tøeba najde cestu k matu na všechny soupeøovy
      tahy). Dealokuje MeziVypocet (není-li nil). }
    procedure PrestanDopredu(nAkceKonecDopredu: TAkce);
    { Zastaví vıpoèet dopøedu. To co vypoèítal si pamatuje v MeziVypocet.
      Myslitel konèící vıpoèet pak zavolá AkceKonecDopredu. }
  end;

function HodnotaToStr(hodnota: longint): string22;

implementation

uses WinTypes, WinProcs, Forms, Rutiny, Rychle, Ohodnoc, Form, SysUtils,
  Sachovni, UKnih, Dialogs, Vypisova, NormForm, DoprForm;

const
  mat = 2147483645;
  NeHodnota = -2147483647;

  { procedure Ladena;
    var w:word;
    begin
    asm
    mov ax,sp
    mov w,ax
    end;
    form1.label33.caption:=inttostr(w);
    end; }
function HodnotaToStr(hodnota: longint): string22;
begin
  if (hodnota < mat - 100) and (hodnota > 100 - mat) then
    result := IntToStr(hodnota)
  else
  begin { blíí se mat }
    if hodnota = NeHodnota then
    begin
      result := 'Nedopoèteno';
      exit
    end;
    if mat + 1 = hodnota then
    begin
      result := '+Nekoneèno';
      exit
    end;
    if -mat - 1 = hodnota then
    begin
      result := '-Nekoneèno';
      exit
    end;
    if hodnota > 0 then
      result := 'Bílı'
    else
      result := 'Èernı';
    if (hodnota = mat) or (hodnota = -mat) then
    begin
      result := result + ' vyhrál';
      exit;
    end;
    if hodnota > 0 then
      hodnota := mat - hodnota
    else
      hodnota := mat + hodnota;
    hodnota := (hodnota + 1) shr 1;
    result := result + ' dá mat ' + IntToStr(hodnota) + '. tahem.'
  end
end;

{ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! }
{ !!!                  Procedury pro práci s PJednoPartie               !!! }
{ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! }
procedure CopyKusPartie(Kde: TPozice; Odkud: ppartie; var Kam: PJednoPartie);
{ Zkopíruje èást partie. Jde od souèasného stavu doleva a po první tah
  pìšcem nebo braní. Budoucnost tj. to, co je vpravo nezkopíruje.
  Je-li poslední tah braní nebo tah pìšcem bude Kam Nil. }
var
  pom, pom2: PJednoPartie;
begin
  Kam := Nil;
  if (Odkud <> nil) { Mìlo by nastat vdy... } then
  begin
    while (Odkud^.l <> nil) and not trvalaa_zmena(Kde, Odkud^.t2) do
    begin
      new(pom);

      pom^.l := Kam;
      pom^.t2 := Odkud^.t2;
      Kam := pom;
      Odkud := Odkud^.l;
      tahni_zpet(Kde, Kam^.t2);
    end; { Teï mám spoják v kam, ale je tøeba ho otoèit }
    pom := nil;
    while Kam <> nil do
    begin
      pom2 := Kam^.l;
      Kam^.l := pom;
      pom := Kam;
      Kam := pom2;
    end;
    Kam := pom;
    { Otoèení dokonèeno }
  end
end;

procedure DonePJednoPartie(var p: PJednoPartie);
{ Dealokace celého spojáku }
var
  pom: PJednoPartie;
begin
  while p <> nil do
  begin
    pom := p^.l;
    dispose(p);

    p := pom;
  end
end;

procedure PridejTah(var Kam: PJednoPartie; co: ttah2);
var
  pom: PJednoPartie;
begin
  new(pom);

  pom^.t2 := co;
  pom^.l := Kam;
  Kam := pom
end;

procedure UberTah(var Odkud: PJednoPartie);
var
  pom: PJednoPartie;
begin
  if Odkud <> nil then
  begin
    pom := Odkud^.l;
    dispose(Odkud);

    Odkud := pom
  end
end;

function PoloRemis(Partie: PJednoPartie; var Pozice: TPozice): Boolean;
{ Dochází v Partii k opakování poslední Pozice nebo aspoò k 50 tichım tahùm ? }
  function stejne(var pos1, pos2: TPozice): Boolean;
  var
    x: byte;
  begin
    result := true;
    if pos1.stav.b <> pos2.stav.b then
      result := false
    else if pos1.stav.mimoch <> pos2.stav.mimoch then
      result := false
    else
      for x := 0 to 63 do
        if pos1.sch[0, x] <> pos2.sch[0, x] then
        begin
          result := false;
          exit
        end;
  end;

var
  th: shortint;
  pompos: TPozice;
begin
  th := 100;
  result := false;
  pompos := Pozice;
  while (Partie <> nil) and (th > 0) do
  begin
    dec(th);
    if trvalaa_zmena(pompos, Partie^.t2) then
      break;
    tahni_zpet(pompos, Partie^.t2);
    if stejne(Pozice, pompos) then
    begin
      result := true;
      break
    end;
    Partie := Partie^.l;
  end;
  if th = 0 then
    result := true
end;

{ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! }
{ !!!                            TMeziVypocet                           !!! }
{ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! }
procedure TMezivypocet.Pridej(var Data: TMeziData);
var
  pom: PMeziSeznam;
begin
  pom := Seznam;
  while (pom <> nil) and (CMPPozice(Data.Pozice, pom^.Data.Pozice) <> 0) do
    pom := pom^.n;
  if pom = nil then
  begin
    new(pom);
    pom^.Data := Data;
    pom^.n := Seznam;
    Seznam := pom
  end
  else
  begin
    if (Data.Hloubka > pom^.Data.Hloubka) or (Data.Hloubka = pom^.Data.Hloubka)
      and (Data.I > pom^.Data.I) then
      pom^.Data := Data
  end
end;

procedure TMezivypocet.DejInfo(var Pozice: TPozice; var AlgCfg: TAlgCfg;
  var Data: TMeziData);
var
  pom: PMeziSeznam;
begin
  pom := Seznam;
  while (pom <> nil) and (CMPPozice(Pozice, pom^.Data.Pozice) <> 0) do
    pom := pom^.n;
  if pom = nil then
  begin
    Data.Hloubka := 0;
    Data.Dojeto := false;
    Data.I := 1;
    Rychle.NalezTahy(Pozice, Data.Tahy);
    Data.Pozice := Pozice; { asi zbyteèné, ale pro jistotu }
    Data.Platnych := 1;
    Data.Hodnoty[1] := HodnotaPozice(Pozice, AlgCfg);
    if Data.Hodnoty[1] > mat - AlgCfg.Okno then
    begin
      Data.Beta := Data.Hodnoty[1] + 1;
      Data.Alfa := Data.Hodnoty[1] - AlgCfg.Okno
    end
    else if Data.Hodnoty[1] < -mat + AlgCfg.Okno then
    begin
      Data.Alfa := Data.Hodnoty[1] - 1;
      Data.Beta := Data.Hodnoty[1] + AlgCfg.Okno
    end
    else
    begin
      Data.Alfa := Data.Hodnoty[1] - AlgCfg.Okno;
      Data.Beta := Data.Hodnoty[1] + AlgCfg.Okno
    end;
  end
  else
    Data := pom^.Data
end;

procedure TMezivypocet.SmazSeznam;
var
  pom: PMeziSeznam;
begin
  while Seznam <> nil do
  begin
    pom := Seznam^.n;
    dispose(Seznam);
    Seznam := pom
  end
end;

destructor TMezivypocet.Destroy;
begin
  SmazSeznam;
  inherited Destroy;
end;

{ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! }
{ !!!                               TMyslitel                           !!! }
{ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! }
constructor TMyslitel.Create(nHraji: TDejtahProc);
begin
  inherited Create;
  MeziVypocet := TMezivypocet.Create;
  CasNaTah := 5000;
  Hraji := nHraji;
end;

destructor TMyslitel.Destroy;
begin
  MeziVypocet.Free;
  inherited Destroy;
end;

procedure TMyslitel.MysliOTahDopredu(var npozice: TPozice; npartie: ppartie);
var
  MeziDataJeho: TMeziData;
  Procedure Jedeme(bily: Boolean);
  var
    poprve: Boolean;
    t2: ttah2;
    MeziDataMoje: TMeziData;
    PomHloubka, K, Dobrych: Integer;
    pocitam, Nejlepsi: ShortString;
  label SkoroKonec;
  begin
    pocitam := '';
    Nejlepsi := '';
    poprve := true;
    repeat
      PomHloubka := MeziDataJeho.Hloubka;
      if poprve or (MeziDataJeho.Tahy.Poctah > 1) then
      begin
        { <Ladící vıpisy> }
        if Vypisovac.Cfg.osPovoleno and Vypisovac.Cfg.osDopredu then
          Vypisovac.WriteStr(' Pøemıšlím co soupeø zahraje...');
        { </Ladící vıpisy> }
        { <Bìné vıpisy> }
        if Vypisovac.Cfg.mdPovoleno then
          MysDopForm.Label4.Caption := 'Vìštím soupeøùv tah.';
        { </Bìné vıpisy> }
        poprve := false;
      end;
      if MeziDataJeho.Tahy.Poctah > 1 then
        repeat
          if bily then
            globBIterace(MeziDataJeho, AlgCfg.DoprHorsiTahy, OnDopredu, pocitam,
              Nejlepsi)
          else
            globCIterace(MeziDataJeho, AlgCfg.DoprHorsiTahy, OnDopredu, pocitam,
              Nejlepsi) until Ukoncit or MeziDataJeho.Dojeto or
              (MeziDataJeho.Hloubka > PomHloubka)
        else
          MeziDataJeho.Dojeto := true;

      Application.Processmessages;

      { <Ladící vıpisy> }
      if MeziDataJeho.Platnych < 1 then
        MeziDataJeho.Platnych := 1;
      Dobrych := 0;
      repeat
        inc(Dobrych)
      until (Dobrych = MeziDataJeho.Tahy.Poctah) or
        (Dobrych = MeziDataJeho.Platnych) or
        (MeziDataJeho.Hodnoty[1] < -mat + 100) or
        (MeziDataJeho.Hodnoty[1] > mat - 100) or
      { Musím si dávat pozor na pøeteèení LongIntu }
        (MeziDataJeho.Hodnoty[Dobrych + 1] < MeziDataJeho.Hodnoty[1] -
        AlgCfg.DoprHorsiTahy) or
        (MeziDataJeho.Hodnoty[Dobrych + 1] > MeziDataJeho.Hodnoty[1] +
        AlgCfg.DoprHorsiTahy);
      for K := 1 to Dobrych do
      begin
        if Ukoncit then
          break;
        if Vypisovac.Cfg.osPovoleno and Vypisovac.Cfg.osDopredu then
          Vypisovac.WriteStr(' Chystám se na soupeøùv tah ' +
            TTah1ToStr(MeziDataJeho.Tahy.t[K], Pozice));
        { </Ladící vıpisy> }
        { <Bìné vıpisy> }
        if Vypisovac.Cfg.mdPovoleno then
          MysDopForm.Label4.Caption := 'Poèítám odpovìï na ' +
            TTah1ToStr(MeziDataJeho.Tahy.t[K], Pozice) + '.';
        { </Bìné vıpisy> }
        DoplnTah(MeziDataJeho.Tahy.t[K], Pozice, t2);
        PridejTah(Partie, t2);
        tahni(Pozice, MeziDataJeho.Tahy.t[K]);
        { A teï myslím na odpovìï }
        MeziVypocet.DejInfo(Pozice, AlgCfg, MeziDataMoje);
        if (not Ukoncit) and (not MeziDataMoje.Dojeto) and
          (MeziDataMoje.Hloubka <= MeziDataJeho.Hloubka) and
          (MeziDataMoje.Tahy.Poctah > 0) then
        begin
          repeat
            if bily then
              globCIterace(MeziDataMoje, AlgCfg.NormHorsiTahy, JaDopredu,
                pocitam, Nejlepsi)
            else
              globBIterace(MeziDataMoje, AlgCfg.DoprHorsiTahy, JaDopredu,
                pocitam, Nejlepsi) until (Ukoncit) or (MeziDataMoje.Dojeto) or
                (MeziDataMoje.Hloubka >= MeziDataJeho.Hloubka);
            MeziVypocet.Pridej(MeziDataMoje);
            if Vypisovac.Cfg.osPovoleno and Vypisovac.Cfg.osDopredu then
              Vypisovac.WriteStr(' Moje odpovìï: ' +
                TTah1ToStr(MeziDataMoje.Tahy.t[1], Pozice));
          end;
          tahni_zpet(Pozice, t2);
          UberTah(Partie);
        end
        until Ukoncit;
      end;

      var
        I: Integer;
        t2: ttah2;
        t1: ttah1;
      begin
        { !!!!!!!!!!!!!!Ladìní!!!!!!!!!!!! }
        if form1.sachovnice.bilyalg.MyslimDopredu or
          form1.sachovnice.cernyalg.MyslimDopredu or
          form1.sachovnice.bilyalg.Myslim or form1.sachovnice.cernyalg.Myslim
        then { jeden z nich jsem já, ale to nevadí }
          ZpravovaKrabice('Mám myslet dopøedu a zatím se u myslí',
            'Hrozná chyba !!!', mb_ok);
        { !!!!!!!!!!!!!!!!!!!!!!!!!! }
        KoncovyCas := mat + 2;
        MyslimDopredu := true;
        { Mat+2 je toti zároveò nejvìtší LongInt, mùu tedy myslet poøád. }
        if Vypisovac.Cfg.osPovoleno and Vypisovac.Cfg.osZakladni then
          Vypisovac.WriteStr('Zaèínám myslet dopøedu...');
        AkceKonecDopredu := nil;
        Ukoncit := false;
        MeziVypocet.SmazSeznam; { Seznam mùe bıt nil, ale to nevadí. }
        Pozice := npozice;
        CopyKusPartie(Pozice, npartie, Partie);
        MeziVypocet.DejInfo(Pozice, AlgCfg, MeziDataJeho);
        { Je sice jisté, e Pozice v mezivıpoètu nebude, to ale nevadí, stejnì to
          najde tahy atd... }
        if MeziDataJeho.Tahy.Poctah > 0 then
        begin
          if AlgCfg.PouzitKnihovnu then
          begin
            I := 1;
            while I <= MeziDataJeho.Tahy.Poctah do
            begin
              DoplnTah(MeziDataJeho.Tahy.t[I], Pozice, t2);
              tahni(Pozice, MeziDataJeho.Tahy.t[I]);
              if Knihovna.DejTah(Pozice, t1) then
              begin
                { nebudu poèítat odpovìï na tah, kterı vede k pozici, co mám v knihovnì }
                MeziDataJeho.Tahy.t[I] := MeziDataJeho.Tahy.t
                  [MeziDataJeho.Tahy.Poctah];
                dec(MeziDataJeho.Tahy.Poctah);
                dec(I)
              end;
              tahni_zpet(Pozice, t2);
              inc(I)
            end;
            Application.Processmessages;
          end; { Od PouzitKnihovnu }
          { Asi není nutné, ale to osekávání pøece jen chvíli trvalo... }
          if (MeziDataJeho.Tahy.Poctah > 0) and not Ukoncit
          then { mohl jsem toti vymazat všechny tahy }
            if hb in Pozice.stav.b then
              Jedeme(true)
            else
              Jedeme(false);
        end;
        DonePJednoPartie(Partie);
        if Vypisovac.Cfg.osPovoleno and Vypisovac.Cfg.osZakladni then
          Vypisovac.WriteStr('Konèím myšlení dopøedu');
        Vypisovac.ZavriSoubor; { Nevadí, jestli není otevøenı }
        if assigned(AkceKonecDopredu) then
          postmessage(form1.handle, wm_Zavolej, 0, longint(@AkceKonecDopredu));
        MyslimDopredu := false;
      end;

      Procedure TMyslitel.VypisVariantu(Tah1: ttah1; Var pocitam: ShortString;
        PocPos: byte; Styl: TStyl; Hloubka: Integer);
      begin
        { <Bìné vıpisy> }
        case Styl of
          Normalni:
            if Vypisovac.Cfg.mnPovoleno and (Vypisovac.Cfg.mnpHloubka >= Hloubka)
            then
            begin
              pocitam[0] := AnsiChar(PocPos);
              pocitam := pocitam + ' ' + TTah1ToStr(Tah1, Pozice);
              MysNormForm.Label6.Caption := pocitam;
            end;
          OnDopredu:
            if Vypisovac.Cfg.mdPovoleno and (Vypisovac.Cfg.mdpHloubka >= Hloubka)
            then
            begin
              pocitam[0] := AnsiChar(PocPos);
              pocitam := pocitam + ' ' + TTah1ToStr(Tah1, Pozice);
              MysDopForm.Label7.Caption := pocitam;
            end;
          JaDopredu:
            if Vypisovac.Cfg.mdPovoleno and (Vypisovac.Cfg.mdpHloubka >= Hloubka)
            then
            begin
              pocitam[0] := AnsiChar(PocPos);
              pocitam := pocitam + ' ' + TTah1ToStr(Tah1, Pozice);
              MysDopForm.Label20.Caption := pocitam;
            end;
        end;
        { </Bìné vıpisy> }
      end;

      Procedure TMyslitel.VypisNejlepsi(Tah1: ttah1; Var Nejlepsi: ShortString;
        Styl: TStyl);
      begin
        { <Bìné vıpisy> }
        case Styl of
          Normalni:
            if Vypisovac.Cfg.mnPovoleno then
              if Vypisovac.Cfg.mnnHloubka > 0 then
                MysNormForm.Label8.Caption := TTah1ToStr(Tah1, Pozice)
                  + Nejlepsi;
          OnDopredu:
            if Vypisovac.Cfg.mdPovoleno then
              if Vypisovac.Cfg.mdnHloubka > 0 then
                MysDopForm.Label9.Caption := TTah1ToStr(Tah1, Pozice) +
                  Nejlepsi;
          JaDopredu:
            if Vypisovac.Cfg.mdPovoleno then
              if Vypisovac.Cfg.mnnHloubka > 0 then
                MysDopForm.Label22.Caption := TTah1ToStr(Tah1, Pozice)
                  + Nejlepsi;
        end;
        { </Bìné vıpisy> }
      end;

      Procedure TMyslitel.globBIterace(var MeziData: TMeziData;
        HorsiTahy: longint; Styl: TStyl; var pocitam, Nejlepsi: ShortString);
      { Volat pouze hraje-li bílı.
        Provedení jedné iterace v Okénku (Alfa,Beta). }
      var
        JeTah, Dj: Boolean;
        I, K: Integer;
        PocPos: byte;
        t2: ttah2;
        { hodnota:LongInt; }
        PomTah: ttah1;
        PomHodnota: longint;
      begin
        if MeziData.Dojeto then
          exit;
        PocPos := length(pocitam);
        Nejlepsi := '';
        { <Bìné vıpisy> }
        case Styl of
          Normalni:
            if Vypisovac.Cfg.mnPovoleno then
              MysNormForm.Label2.Caption := IntToStr(MeziData.Hloubka);
          OnDopredu:
            if Vypisovac.Cfg.mdPovoleno then
              MysDopForm.Label11.Caption := IntToStr(MeziData.Hloubka);
          JaDopredu:
            if Vypisovac.Cfg.mdPovoleno then
              MysDopForm.Label16.Caption := IntToStr(MeziData.Hloubka);
        end;
        { </Bìné vıpisy> }
        { <Ladící vıpisy> }
        if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
          (Vypisovac.Cfg.osHloubka > 0) then
          case Styl of
            Normalni:
              if Vypisovac.Cfg.osNormalni then
                Vypisovac.WriteZacatekIterace(MeziData);
            OnDopredu, JaDopredu:
              if Vypisovac.Cfg.osDopredu then
                Vypisovac.WriteZacatekIterace(MeziData);
          end;
        { </Ladící vıpisy> }
        MeziData.Dojeto := true;
        JeTah := false;
        if MeziData.I = 1 then
          MeziData.Platnych := 1;
        for I := MeziData.I to MeziData.Tahy.Poctah do
        begin
          MeziData.I := I;
          { <Bìné vıpisy> }
          VypisVariantu(MeziData.Tahy.t[I], pocitam, PocPos, Styl, 1);
          { </Bìné vıpisy> }
          { <Ladící vıpisy> }
          if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
            (Vypisovac.Cfg.osHloubka > 1) then
            if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
              Vypisovac.Cfg.osDopredu and
              ((Styl = OnDopredu) or (Styl = JaDopredu)) then
            begin
              Vypisovac.WritePocitamTah(MeziData, 4)
            end;
          { </Ladící vıpisy> }
          DoplnTah(MeziData.Tahy.t[I], Pozice, t2);
          tahni(Pozice, MeziData.Tahy.t[I]);
          PridejTah(Partie, t2);
          if PoloRemis(Partie, Pozice) then
            MeziData.Hodnoty[I] := 0
          else
          begin
            MeziData.Hodnoty[I] := Alfa_Beta(MeziData.Alfa, MeziData.Beta,
              MeziData.Hloubka, Dj, 2, Styl, pocitam, Nejlepsi);
            if MeziData.Hodnoty[I] <> NeHodnota then
              if MeziData.Hodnoty[I] > mat - 100 then
                dec(MeziData.Hodnoty[I])
              else if MeziData.Hodnoty[I] < -mat + 100 then
                inc(MeziData.Hodnoty[I]);
            if not Dj then
              MeziData.Dojeto := false; { nedopoèetl-li jsem aspoò 1 tah,
              je to celé nedopoètené }
          end;
          UberTah(Partie);
          tahni_zpet(Pozice, t2);
          if MeziData.Hodnoty[I] = NeHodnota then
          begin
            MeziData.Dojeto := false;
            pocitam[0] := AnsiChar(PocPos);
            exit
          end;
          if MeziData.Hodnoty[I] > MeziData.Alfa then
          begin
            { 2. zmìna } { probublám dobrım tahem dopøedu a to i v pøípadì, e není v (alfa,beta) }
            K := I;
            while (K > 1) and (MeziData.Hodnoty[K - 1] < MeziData.Hodnoty[K]) do
            begin
              PomTah := MeziData.Tahy.t[K];
              PomHodnota := MeziData.Hodnoty[K];
              MeziData.Tahy.t[K] := MeziData.Tahy.t[K - 1];
              MeziData.Hodnoty[K] := MeziData.Hodnoty[K - 1];
              MeziData.Tahy.t[K - 1] := PomTah;
              MeziData.Hodnoty[K - 1] := PomHodnota;
              dec(K)
            end;
            if MeziData.Hodnoty[1] >= MeziData.Beta then
            begin
              { <Ladící vıpisy> }
              if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
                (Vypisovac.Cfg.osHloubka > 0) then
                if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
                  Vypisovac.Cfg.osDopredu and
                  ((Styl = OnDopredu) or (Styl = JaDopredu)) then
                begin
                  Vypisovac.WriteStr('  Neúspìch iterace');
                  Vypisovac.WriteStr('  Pøelezl jsem okénko tahem ' +
                    TTah1ToStr(MeziData.Tahy.t[1], Pozice))
                end;
              { </Ladící vıpisy> }
              MeziData.I := 1;
              MeziData.Alfa := MeziData.Beta - 1;
              MeziData.Beta := mat;
              pocitam[0] := AnsiChar(PocPos);
              exit { Okénko moc dole }
            end; { od pøelezení okénka }
            JeTah := true;
            if I <> 1 then
              inc(MeziData.Platnych);
            { 3. zmìna } If K = 1 then
            begin
              { Tah je nejen v intervalu (alfa, beta), ale je skuteènì nejlepší }
              if (MeziData.Hodnoty[1] > mat - 100) or
                (MeziData.Hodnoty[1] < -mat + 100) then
                MeziData.Alfa := MeziData.Hodnoty[1]
              else if MeziData.Alfa < MeziData.Hodnoty[1] - HorsiTahy then
                MeziData.Alfa := MeziData.Hodnoty[1] - HorsiTahy;
              { <Bìné vıpisy> }
              VypisNejlepsi(MeziData.Tahy.t[1], Nejlepsi, Styl);
              case Styl of
                Normalni:
                  if Vypisovac.Cfg.mnPovoleno then
                    MysNormForm.Label4.Caption :=
                      HodnotaToStr(MeziData.Hodnoty[1]);
                OnDopredu:
                  if Vypisovac.Cfg.mdPovoleno then
                    MysDopForm.Label13.Caption :=
                      HodnotaToStr(MeziData.Hodnoty[1]);
                JaDopredu:
                  if Vypisovac.Cfg.mdPovoleno then
                    MysDopForm.Label18.Caption :=
                      HodnotaToStr(MeziData.Hodnoty[1]);
              end;
              { </Bìné vıpisy> }
              { <Ladící vıpisy> }
              if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
                (Vypisovac.Cfg.osHloubka > 0) then
                if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
                  Vypisovac.Cfg.osDopredu and
                  ((Styl = OnDopredu) or (Styl = JaDopredu)) then
                  Vypisovac.WriteDobryTah(MeziData) { je to dobøe ? };
              { </Ladící vıpisy> }
            end;

            if JeTah and (MeziData.Alfa >= mat - MeziData.Hloubka) then
            begin
              MeziData.Dojeto := true;
              pocitam[0] := AnsiChar(PocPos);
              exit;
            end
          end
        end; { od for cyklu pøes tahy }
        if not JeTah then
        begin
          { <Ladící vıpisy> }
          if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
            (Vypisovac.Cfg.osHloubka > 0) then
            if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
              Vypisovac.Cfg.osDopredu and
              ((Styl = OnDopredu) or (Styl = JaDopredu)) then
            begin
              Vypisovac.WriteStr('  Neúspìch iterace');
              Vypisovac.WriteStr('  Všechny tahy byly pod okénkem')
            end;
          { </Ladící vıpisy> }
          MeziData.Alfa := -mat;
          MeziData.Beta := MeziData.Hodnoty[1] + 1;
          MeziData.I := 1;
          { Okénko moc nahoøe }
        end
        else
        begin
          if (MeziData.Alfa <= -mat + MeziData.Hloubka) then
          begin
            MeziData.Dojeto := true;
            pocitam[0] := AnsiChar(PocPos);
            exit;
          end;
          MeziData.I := 1;
          if MeziData.Hodnoty[1] < -mat + AlgCfg.Okno then
            MeziData.Alfa := MeziData.Hodnoty[1] - 1
          else
            MeziData.Alfa := MeziData.Hodnoty[1] - AlgCfg.Okno;
          if MeziData.Hodnoty[1] > mat - AlgCfg.Okno then
            MeziData.Beta := MeziData.Hodnoty[1] + 1
          else
            MeziData.Beta := MeziData.Hodnoty[1] + AlgCfg.Okno;
          inc(MeziData.Hloubka)
        end;
        pocitam[0] := AnsiChar(PocPos);
      end; { Konec BIterace }

      Procedure TMyslitel.globCIterace(var MeziData: TMeziData;
        HorsiTahy: longint; Styl: TStyl; var pocitam, Nejlepsi: ShortString);
      { Volat pouze hraje-li èernı.
        Provedení jedné iterace v Okénku (Alfa,Beta). }
      var
        JeTah, Dj: Boolean;
        I, K: Integer;
        PocPos: byte;
        t2: ttah2;
        PomTah: ttah1;
        PomHodnota: longint;
      begin
        if MeziData.Dojeto then
          exit;
        PocPos := length(pocitam);
        Nejlepsi := '';
        { <Bìné vıpisy> }
        case Styl of
          Normalni:
            if Vypisovac.Cfg.mnPovoleno then
              MysNormForm.Label2.Caption := IntToStr(MeziData.Hloubka);
          OnDopredu:
            if Vypisovac.Cfg.mdPovoleno then
              MysDopForm.Label11.Caption := IntToStr(MeziData.Hloubka);
          JaDopredu:
            if Vypisovac.Cfg.mdPovoleno then
              MysDopForm.Label16.Caption := IntToStr(MeziData.Hloubka);
        end;
        { </Bìné vıpisy> }
        { <Ladící vıpisy> }
        if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
          (Vypisovac.Cfg.osHloubka > 0) then
          case Styl of
            Normalni:
              if Vypisovac.Cfg.osNormalni then
                Vypisovac.WriteZacatekIterace(MeziData);
            OnDopredu, JaDopredu:
              if Vypisovac.Cfg.osDopredu then
                Vypisovac.WriteZacatekIterace(MeziData);
          end;
        { </Ladící vıpisy> }
        MeziData.Dojeto := true;
        JeTah := false;
        if MeziData.I = 1 then
          MeziData.Platnych := 1;
        for I := MeziData.I to MeziData.Tahy.Poctah do
        begin
          MeziData.I := I;
          { <Bìné vıpisy> }
          VypisVariantu(MeziData.Tahy.t[I], pocitam, PocPos, Styl, 1);
          { </Bìné vıpisy> }
          { <Ladící vıpisy> }
          if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
            (Vypisovac.Cfg.osHloubka > 1) then
            if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
              Vypisovac.Cfg.osDopredu and
              ((Styl = OnDopredu) or (Styl = JaDopredu)) then
            begin
              Vypisovac.WritePocitamTah(MeziData, 4)
            end;
          { </Ladící vıpisy> }
          DoplnTah(MeziData.Tahy.t[I], Pozice, t2);
          tahni(Pozice, MeziData.Tahy.t[I]);
          PridejTah(Partie, t2);
          if PoloRemis(Partie, Pozice) then
            MeziData.Hodnoty[I] := 0
          else
          begin
            MeziData.Hodnoty[I] := Alfa_Beta(MeziData.Alfa, MeziData.Beta,
              MeziData.Hloubka, Dj, 2, Styl, pocitam, Nejlepsi);
            if MeziData.Hodnoty[I] <> NeHodnota then
              if MeziData.Hodnoty[I] > mat - 100 then
                dec(MeziData.Hodnoty[I])
              else if MeziData.Hodnoty[I] < -mat + 100 then
                inc(MeziData.Hodnoty[I]);
            if not Dj then
              MeziData.Dojeto := false; { nedopoèetl-li jsem aspoò 1 tah,
              je to celé nedopoètené }
          end;
          UberTah(Partie);
          tahni_zpet(Pozice, t2);
          if MeziData.Hodnoty[I] = NeHodnota then
          begin
            MeziData.Dojeto := false;
            pocitam[0] := AnsiChar(PocPos);
            exit
          end;
          if MeziData.Hodnoty[I] < MeziData.Beta then
          begin
            { 2. zmìna } { probublám dobrım tahem dopøedu a to i v pøípadì, e není v (alfa,beta) }
            K := I;
            while (K > 1) and (MeziData.Hodnoty[K - 1] > MeziData.Hodnoty[K]) do
            begin
              PomTah := MeziData.Tahy.t[K];
              PomHodnota := MeziData.Hodnoty[K];
              MeziData.Tahy.t[K] := MeziData.Tahy.t[K - 1];
              MeziData.Hodnoty[K] := MeziData.Hodnoty[K - 1];
              MeziData.Tahy.t[K - 1] := PomTah;
              MeziData.Hodnoty[K - 1] := PomHodnota;
              dec(K)
            end;
            if MeziData.Hodnoty[1] <= MeziData.Alfa then
            begin
              { <Ladící vıpisy> }
              if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
                (Vypisovac.Cfg.osHloubka > 0) then
                if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
                  Vypisovac.Cfg.osDopredu and
                  ((Styl = OnDopredu) or (Styl = JaDopredu)) then
                begin
                  Vypisovac.WriteStr('  Neúspìch iterace');
                  Vypisovac.WriteStr('  Podlezl jsem okénko tahem ' +
                    TTah1ToStr(MeziData.Tahy.t[1], Pozice))
                end;
              { </Ladící vıpisy> }
              MeziData.I := 1;
              MeziData.Beta := MeziData.Alfa + 1;
              MeziData.Alfa := -mat;
              pocitam[0] := AnsiChar(PocPos);
              exit { Okénko moc nahoøe }
            end; { od podlezení okénka }
            JeTah := true;
            if I <> 1 then
              inc(MeziData.Platnych);
            { 3. zmìna } If K = 1 then
            begin
              { Tah je nejen v intervalu (alfa, beta), ale je skuteènì nejlepší }
              if (MeziData.Hodnoty[1] > mat - 100) or
                (MeziData.Hodnoty[1] < -mat + 100) then
                MeziData.Beta := MeziData.Hodnoty[1]
              else if MeziData.Beta > MeziData.Hodnoty[1] + HorsiTahy then
                MeziData.Beta := MeziData.Hodnoty[1] + HorsiTahy;
              { <Bìné vıpisy> }
              VypisNejlepsi(MeziData.Tahy.t[1], Nejlepsi, Styl);
              case Styl of
                Normalni:
                  if Vypisovac.Cfg.mnPovoleno then
                    MysNormForm.Label4.Caption :=
                      HodnotaToStr(MeziData.Hodnoty[1]);
                OnDopredu:
                  if Vypisovac.Cfg.mdPovoleno then
                    MysDopForm.Label13.Caption :=
                      HodnotaToStr(MeziData.Hodnoty[1]);
                JaDopredu:
                  if Vypisovac.Cfg.mdPovoleno then
                    MysDopForm.Label18.Caption :=
                      HodnotaToStr(MeziData.Hodnoty[1]);
              end;
              { </Bìné vıpisy> }
              { <Ladící vıpisy> }
              if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
                (Vypisovac.Cfg.osHloubka > 0) then
                if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
                  Vypisovac.Cfg.osDopredu and
                  ((Styl = OnDopredu) or (Styl = JaDopredu)) then
                  Vypisovac.WriteDobryTah(MeziData);
              { </Ladící vıpisy> }
            end;

            if JeTah and (MeziData.Beta <= -mat + MeziData.Hloubka) then
            begin
              MeziData.Dojeto := true;
              pocitam[0] := AnsiChar(PocPos);
              exit;
            end
          end
        end; { od for cyklu pøes tahy }
        if not JeTah then
        begin
          { <Ladící vıpisy> }
          if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
            (Vypisovac.Cfg.osHloubka > 0) then
            if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
              Vypisovac.Cfg.osDopredu and
              ((Styl = OnDopredu) or (Styl = JaDopredu)) then
            begin
              Vypisovac.WriteStr('  Neúspìch iterace');
              Vypisovac.WriteStr('  Všechny tahy byly nad okénkem')
            end;
          { </Ladící vıpisy> }
          MeziData.Beta := mat;
          MeziData.Alfa := MeziData.Hodnoty[1] - 1;
          MeziData.I := 1;
          { Okénko moc dole }
        end
        else
        begin
          { if (Mezidata.alfa<=-mat+Mezidata.hloubka) then
            begin
            Mezidata.dojeto:=true;
            Pocitam[0]:=char(PocPos);
            exit;
            end; }
          if (MeziData.Beta >= mat - MeziData.Hloubka) then
          begin
            MeziData.Dojeto := true;
            pocitam[0] := AnsiChar(PocPos);
            exit;
          end;
          MeziData.I := 1;
          if MeziData.Hodnoty[1] < -mat + AlgCfg.Okno then
            MeziData.Alfa := MeziData.Hodnoty[1] - 1
          else
            MeziData.Alfa := MeziData.Hodnoty[1] - AlgCfg.Okno;
          if MeziData.Hodnoty[1] > mat - AlgCfg.Okno then
            MeziData.Beta := MeziData.Hodnoty[1] + 1
          else
            MeziData.Beta := MeziData.Hodnoty[1] + AlgCfg.Okno;
          inc(MeziData.Hloubka)
        end;
        pocitam[0] := AnsiChar(PocPos);
      end; { Konec CIterace }

      procedure TMyslitel.DejTah(var npozice: TPozice; var npartie: ppartie);
      var
        MeziData: TMeziData;
        Procedure Jedeme(bily: Boolean);
        var
          pocitam, Nejlepsi: ShortString;
        begin
          pocitam := '';
          Nejlepsi := '';
          repeat
            if bily then
              globBIterace(MeziData, AlgCfg.NormHorsiTahy, Normalni,
                pocitam, Nejlepsi)
            else
              globCIterace(MeziData, AlgCfg.NormHorsiTahy, Normalni, pocitam,
                Nejlepsi) until Ukoncit or MeziData.Dojeto;
          end;
          Label konec;
          var
            Dobrych, K: Integer;
          begin { DejTah }
            { !!!!!!!!!!!!!!Ladìní!!!!!!!!!!!! }
            if form1.sachovnice.bilyalg.MyslimDopredu or
              form1.sachovnice.cernyalg.MyslimDopredu or
              form1.sachovnice.bilyalg.Myslim or form1.sachovnice.cernyalg.Myslim
            then { jeden z nich jsem já, ale to nevadí }
              ZpravovaKrabice('Mám myslet a zatím se u myslí',
                'Hrozná chyba !!!', mb_ok);
            { !!!!!!!!!!!!!!!!!!!!!!!!!! }
            KoncovyCas := CasNaTah + GetTickCount;
            if Vypisovac.Cfg.osPovoleno and Vypisovac.Cfg.osZakladni then
              Vypisovac.WriteStr('Zaèínám myslet...');
            Myslim := true;
            Ukoncit := false;
            Pozice := npozice;
            if AlgCfg.PouzitKnihovnu and Knihovna.DejTah(Pozice,
              MeziData.Tahy.t[1]) then
              goto konec;

            MeziVypocet.DejInfo(Pozice, AlgCfg, MeziData);
            CopyKusPartie(Pozice, npartie, Partie);
            if MeziData.Tahy.Poctah > 1 then { Pokud má smysl pøemıšlet tak }
              if hb in Pozice.stav.b then
                Jedeme(true)
              else
                Jedeme(false);
            { ..else mám jen jeden pøípustnı tah }
            DonePJednoPartie(Partie);
            if MeziData.Platnych < 1 then
              MeziData.Platnych := 1;
            Dobrych := 0;
            repeat
              inc(Dobrych)
            until (Dobrych = MeziData.Tahy.Poctah) or
              (Dobrych = MeziData.Platnych) or
              (MeziData.Hodnoty[1] < -mat + 100) or
              (MeziData.Hodnoty[1] > mat - 100) or
              (MeziData.Hodnoty[Dobrych + 1] < MeziData.Hodnoty[1] -
              AlgCfg.Nedeterminismus) or
              (MeziData.Hodnoty[Dobrych + 1] > MeziData.Hodnoty[1] +
              AlgCfg.Nedeterminismus);
            if Vypisovac.Cfg.osPovoleno and Vypisovac.Cfg.osNormalni then
            begin
              Vypisovac.WriteStr('Celkem platnıch tahù: ' +
                IntToStr(MeziData.Platnych));
              Vypisovac.WriteStr('Dobré tahy:');
              for K := 1 to Dobrych do
                Vypisovac.WriteStr('Tah: ' + TTah1ToStr(MeziData.Tahy.t[K],
                  Pozice) + ' cena ' + HodnotaToStr(MeziData.Hodnoty[1]));
            end;
            K := random(Dobrych) + 1;
            { if k<>1 then zpravovakrabice('','Nehraji nejlepší tah',mb_ok); }
            MeziData.Tahy.t[1] := MeziData.Tahy.t[K];
          konec:;
            if Vypisovac.Cfg.osPovoleno and Vypisovac.Cfg.osZakladni then
              Vypisovac.WriteStr('Myšlení ukonèeno. Zahraji ' +
                TTah1ToStr(MeziData.Tahy.t[1], Pozice) + '.');
            Vypisovac.ZavriSoubor; { Nevadí, jestli není otevøenı }
            Hraji(MeziData.Tahy.t[1]);
            Myslim := false;
          end;

          procedure TMyslitel.HrajTed;
          begin
            Ukoncit := true
          end;

          procedure TMyslitel.PrestanDopredu(nAkceKonecDopredu: TAkce);
          begin
            AkceKonecDopredu := nAkceKonecDopredu;
            if MyslimDopredu then
              Ukoncit := true
            else if assigned(AkceKonecDopredu) then
              postmessage(form1.handle, wm_Zavolej, 0,
                longint(@AkceKonecDopredu));
          end;

          function TMyslitel.Transformuj(co: longint): longint;
          begin
            if co = NeHodnota then
              result := NeHodnota
            else if co > mat - 100 then
              result := co - 1
            else if co < -mat + 100 then
              result := co + 1
            else
              result := co;
          end;

          function TMyslitel.MusimKoncit: Boolean;
          begin
            result := false;
            inc(VolanoMusimKoncit);
            if Ukoncit = true then
              result := true
            else if { (VolanoMusimKoncit and $F)=0 } true then
              if GetTickCount > KoncovyCas then
              begin
                Ukoncit := true;
                result := true
              end;
            if { (VolanoMusimKoncit and $F)=0 } true then
              Application.Processmessages
          end;

          function TMyslitel.Alfa_Beta_Vrazi(Alfa, Beta: longint;
            Hloubka: Integer; var Dojeto: Boolean; HloubkaRekurze: Integer;
            Styl: TStyl): longint;
          var
            Tahy: TTahy;
            t2: ttah2;
            pomtah1: ttah1;
            HodnotyTahu: THodnotyTahu;
            sach, Dj: Boolean;
            hodnota, HodPos, sAlfa, sBeta, pomlongint: longint;
            h: Integer;
            I: byte;
          begin
            Dojeto := false;
            if (Alfa < -mat + 100) and (Alfa >= -mat) then
              Alfa := Alfa - 1;
            if (Beta > mat - 100) and (Beta <= mat) then
              Beta := Beta + 1;
            if MusimKoncit then
              result := NeHodnota
            else
            begin
              sach := {$IFDEF JENBRANI}nalezbrani{$ELSE}nalezvrahy{$ENDIF}(Pozice, Tahy);
              if Tahy.Poctah = 0 then
              begin
                Dojeto := true;
                if sach then { Je-li nìkdo v šachu a nemá pøípustnı vrah (a zde je
                    vrahem kadı tah), je v matu. }
                  if hb in Pozice.stav.b then
                    result := -mat
                  else
                    result := mat
                else
                  result := HodnotaPozice(Pozice, AlgCfg);
              end { Od Tahy.poctah=0 }
              else
              begin
                if Hloubka = 0 then
                begin
                  result := HodnotaPozice(Pozice, AlgCfg);
                  Dojeto := false { vraedná variata pokraèuje, ale nedopoèetl jsem ji }
                end
                else
                begin
                  sAlfa := Alfa;
                  sBeta := Beta; { V kaskádovém prùchodu bych si je rozhasil }
                  if not sach then
                  begin
                    { Není-li hráè v šachu, nemusí nutnì pokraèovat ve vraedné variantì a mùe
                      se od ní odchılit. Aneb jinak bych poèítal, jako by se v šachách muselo
                      brát. Je-li ale v šachu, je jeho další tah vdy vrah, take mu dalším
                      propoètem nekøivdím. }
                    HodPos := HodnotaPozice(Pozice, AlgCfg);
                    if (hb in Pozice.stav.b) and (HodPos >= sBeta) or
                      not(hb in Pozice.stav.b) and (HodPos <= sAlfa) then
                    begin
                      Dojeto := true;
                      result := HodPos;
                      exit { nevešel jsem se do (alfa, beta), navíc špatnım smìrem }
                    end;
                  end;
                  for I := 1 to Tahy.Poctah do
                    HodnotyTahu[I] := NeHodnota;
                  if hb in Pozice.stav.b then { Hraje bílı }
                  begin
                    if (not sach) and (HodPos > sAlfa) then
                    begin
                      sAlfa := HodPos;
                      if sAlfa >= sBeta then
                      begin
                        result := HodPos;
                        Dojeto := true;
                        exit
                      end
                    end;
                    for h := 0 to Hloubka - 1 do
                    begin
                      Dojeto := true;
                      Alfa := sAlfa;
                      Beta := sBeta;
                      for I := 1 to Tahy.Poctah do
                      begin
                        if HodnotyTahu[I] <> NeHodnota then
                          hodnota := HodnotyTahu[I]
                          { tj. if poèítal bych ji vypoètené, pøeètu si ti z pole }
                        else
                        begin { musím poèítat }
                          DoplnTah(Tahy.t[I], Pozice, t2);
                          tahni(Pozice, Tahy.t[I]);
                          PridejTah(Partie, t2);
                          if PoloRemis(Partie, Pozice) then
                            hodnota := 0
                          else
                            Dj := true;
                          hodnota :=
                            Transformuj(Alfa_Beta_Vrazi(Alfa, Beta, h, Dj,
                            HloubkaRekurze + 1, Styl));
                          UberTah(Partie);
                          if Dj then
                            HodnotyTahu[I] := hodnota
                            { Tah je dopoèítán, zapamatuji si hodnotu }
                          else
                            Dojeto := false; { nedopoèetl-li jsem aspoò 1 tah,
                            je to celé nedopoètené }
                          tahni_zpet(Pozice, t2);
                          if hodnota = NeHodnota then
                          begin
                            result := NeHodnota;
                            exit
                          end;
                        end; { od musím poèítat }
                        if hodnota > Alfa then
                        begin
                          Alfa := hodnota;
                          if Alfa >= Beta then
                            if h = Hloubka - 1 then
                            begin
                              result := Alfa;
                              Dojeto := false;
                              exit
                            end
                            else
                            begin
                              break
                            end;
                          pomtah1 := Tahy.t[I];
                          pomlongint := HodnotyTahu[I];
                          Tahy.t[I] := Tahy.t[1];
                          HodnotyTahu[I] := HodnotyTahu[1];
                          Tahy.t[1] := pomtah1;
                          HodnotyTahu[1] := pomlongint;
                        end
                      end; { od for cyklu pøes tahy }
                      result := Alfa;
                      if Dojeto then
                        break; { Dopoèítal jsem to a do konce. Zvıšení
                        hloubky propoètu nemá smysl (poèítal bych ji vypoètené). }
                    end { od cyklu pøes hloubku }
                  end { od hb in pozice.stav.b }
                  else { Hraje èernı }
                  begin
                    if (not sach) and (HodPos < sBeta) then
                    begin
                      sBeta := HodPos;
                      if sAlfa >= sBeta then
                      begin
                        result := HodPos;
                        Dojeto := true;
                        exit
                      end
                    end;
                    for h := 0 to Hloubka - 1 do
                    begin
                      Dojeto := true;
                      Alfa := sAlfa;
                      Beta := sBeta;
                      for I := 1 to Tahy.Poctah do
                      begin
                        if HodnotyTahu[I] <> NeHodnota then
                          hodnota := HodnotyTahu[I]
                          { tj. if poèítal bych ji vypoètené, pøeètu si ti z pole }
                        else
                        begin { musím poèítat }
                          DoplnTah(Tahy.t[I], Pozice, t2);
                          tahni(Pozice, Tahy.t[I]);
                          PridejTah(Partie, t2);
                          Dj := true;
                          if PoloRemis(Partie, Pozice) then
                            hodnota := 0
                          else
                            hodnota :=
                              Transformuj(Alfa_Beta_Vrazi(Alfa, Beta, h, Dj,
                              HloubkaRekurze + 1, Styl));
                          UberTah(Partie);
                          if Dj then
                            HodnotyTahu[I] := hodnota
                            { Tah je dopoèítán, zapamatuji si hodnotu }
                          else
                            Dojeto := false; { nedopoèetl-li jsem aspoò 1 tah,
                            je to celé nedopoètené }
                          tahni_zpet(Pozice, t2);
                          if hodnota = NeHodnota then
                          begin
                            result := NeHodnota;
                            exit
                          end;
                        end; { od musím poèítat }
                        if hodnota < Beta then
                        begin
                          Beta := hodnota;
                          if Alfa >= Beta then
                            if h = Hloubka - 1 then
                            begin
                              result := Alfa;
                              Dojeto := false;
                              exit
                            end
                            else
                            begin
                              break
                            end;
                          pomtah1 := Tahy.t[I];
                          pomlongint := HodnotyTahu[I];
                          Tahy.t[I] := Tahy.t[1];
                          HodnotyTahu[I] := HodnotyTahu[1];
                          Tahy.t[1] := pomtah1;
                          HodnotyTahu[1] := pomlongint;
                        end
                      end; { od for cyklu pøes tahy }
                      result := Beta;
                      if Dojeto then
                        break; { Dopoèítal jsem to a do konce. Zvıšení
                        hloubky propoètu nemá smysl (poèítal bych ji vypoètené). }
                    end; { Od cyklu pøes hloubku }
                  end { Od hraje èernı }
                end { od not(hloubka=0) }
              end { od not(tahy.poctah=0) }
            end { Od not MusimKoncit }
          end; { Od Alfa_Beta_Vrazi }

          { Aèkoliv jsem víceménì vyznavaèem Pascalu, kdy vidím tolik endù za sebou... }
          function TMyslitel.Alfa_Beta(Alfa, Beta: longint; Hloubka: Integer;
            var Dojeto: Boolean; HloubkaRekurze: Integer; Styl: TStyl;
            var pocitam, Nejlepsi: ShortString): longint;
          var
            Tahy: TTahy;
            t2: ttah2;
            pomtah1: ttah1;
            HodnotyTahu: THodnotyTahu;
            sach, Dj: Boolean;
            hodnota, sAlfa, sBeta, pomlongint: longint;
            h: Integer;
            I, PocPos, NejPos: byte;
            PomStr: ShortString;
          begin
            if (Alfa < -mat + 100) and (Alfa >= -mat) then
              Alfa := Alfa - 1;
            if (Beta > mat - 100) and (Beta <= mat) then
              Beta := Beta + 1;
            PocPos := length(pocitam);
            NejPos := length(Nejlepsi);
            if MusimKoncit then
              result := NeHodnota
            else
            begin { nemusím konèit }
              Dojeto := false;
              if Hloubka = 0 then
              begin
                result := { HodnotaPozice(Pozice,AlgCfg); }
                  Transformuj(Alfa_Beta_Vrazi(Alfa, Beta, HloubkaRekurze + 1,
                  sach { nìjakı nepouitı boolean } ,
                  HloubkaRekurze + 1, Styl));
                if result = mat - 1 then
                  result := mat
                else if result = -mat + 1 then
                  result := -mat;
                if (result = mat) or (result = -mat) then
                  Dojeto := true { Jsem v matu }
                else
                  Dojeto := false; { variata pokraèuje, ale nedopoèetl jsem ji }
                { <Ladící vıpisy> }
                if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
                  (Vypisovac.Cfg.osHloubka > HloubkaRekurze) then
                  if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
                    Vypisovac.Cfg.osDopredu and
                    ((Styl = OnDopredu) or (Styl = JaDopredu)) then
                  begin
                    Vypisovac.writeStrOdsaz('Dopoèet do tiché pozice: ' +
                      HodnotaToStr(result), HloubkaRekurze + 2)
                  end;
                { </Ladící vıpisy> }

              end { od hloubka=0 }
              else
              begin { hloubka>0 }
                { <Ladící vıpisy> }
                if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
                  (Vypisovac.Cfg.osHloubka > HloubkaRekurze) then
                  if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
                    Vypisovac.Cfg.osDopredu and
                    ((Styl = OnDopredu) or (Styl = JaDopredu)) then
                  begin
                    Vypisovac.writeZacatekAlfaBeta(Alfa, Beta, Hloubka,
                      HloubkaRekurze)
                  end;
                { </Ladící vıpisy> }
                sach := Rychle.NalezTahy(Pozice, Tahy);
                if Tahy.Poctah = 0 then
                begin
                  if sach then { Je-li nìkdo v šachu a nemá pøípustnı tah je v matu. }
                    if hb in Pozice.stav.b then
                      result := -mat
                    else
                      result := mat
                  else
                    result := 0; { remis }
                  Dojeto := true;
                end { Od Tahy.poctah=0 }
                else
                begin
                  for I := 1 to Tahy.Poctah do
                    HodnotyTahu[I] := NeHodnota;
                  sAlfa := Alfa;
                  sBeta := Beta;
                  if hb in Pozice.stav.b then { Hraje bílı }
                  begin
                    result := Alfa;
                    for h := 0 to Hloubka - 1 do
                    begin
                      { <Ladící vıpisy> }
                      if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
                        (Vypisovac.Cfg.osHloubka > HloubkaRekurze) then
                        if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
                          Vypisovac.Cfg.osDopredu and
                          ((Styl = OnDopredu) or (Styl = JaDopredu)) then
                        begin
                          Vypisovac.writeZacatekAlfaBetaIterace(sAlfa, sBeta, h,
                            HloubkaRekurze)
                        end;
                      { </Ladící vıpisy> }
                      pocitam[0] := AnsiChar(PocPos);
                      Dojeto := true;
                      Alfa := sAlfa;
                      Beta := sBeta;
                      for I := 1 to Tahy.Poctah do
                      begin
                        { <Bìné vıpisy> }
                        VypisVariantu(Tahy.t[I], pocitam, PocPos, Styl,
                          HloubkaRekurze);
                        { </Bìné vıpisy> }
                        { <Ladící vıpisy> }
                        if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
                          (Vypisovac.Cfg.osHloubka > HloubkaRekurze) then
                          if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
                            Vypisovac.Cfg.osDopredu and
                            ((Styl = OnDopredu) or (Styl = JaDopredu)) then
                          begin
                            Vypisovac.writeStrOdsaz
                              (TTah1ToStr(Tahy.t[I], Pozice),
                              3 + HloubkaRekurze)
                          end;
                        { </Ladící vıpisy> }

                        if HodnotyTahu[I] <> NeHodnota then
                        begin
                          hodnota := HodnotyTahu[I];
                          PomStr := '';
                        end
                        { tj. if poèítal bych ji vypoètené, pøeètu si to z pole }
                        else
                        begin { musím poèítat }
                          DoplnTah(Tahy.t[I], Pozice, t2);
                          tahni(Pozice, Tahy.t[I]);
                          PridejTah(Partie, t2);
                          Dj := true;
                          if PoloRemis(Partie, Pozice) then
                            hodnota := 0
                          else
                          begin
                            PomStr := '';
                            hodnota :=
                              Transformuj(Alfa_Beta(Alfa, Beta, h, Dj,
                              HloubkaRekurze + 1, Styl, pocitam, PomStr));
                          end;
                          UberTah(Partie);
                          if Dj then
                            HodnotyTahu[I] := hodnota
                            { Tah je dopoèítán, zapamatuji si hodnotu }
                          else
                            Dojeto := false; { nedopoèetl-li jsem aspoò 1 tah,
                            je to celé nedopoètené }
                          tahni_zpet(Pozice, t2);
                          if hodnota = NeHodnota then
                          begin
                            result := NeHodnota;
                            pocitam[0] := AnsiChar(PocPos);
                            exit
                          end;
                        end; { od musím poèítat }
                        if hodnota > Alfa then
                        begin
                          Alfa := hodnota;
                          result := Alfa;
                          { <Ladící vıpisy> }
                          if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
                            (Vypisovac.Cfg.osHloubka > HloubkaRekurze) then
                            if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
                              Vypisovac.Cfg.osDopredu and
                              ((Styl = OnDopredu) or (Styl = JaDopredu)) then
                            begin
                              Vypisovac.writeStrOdsaz('Zlepšující tah, Alfa=' +
                                HodnotaToStr(Alfa), 3 + HloubkaRekurze)
                            end;
                          { </Ladící vıpisy> }
                          if Alfa >= Beta then
                            if h = Hloubka - 1 then
                            begin
                              result := Beta;
                              Dojeto := false;
                              pocitam[0] := AnsiChar(PocPos);
                              exit
                            end
                            else
                              break;
                          pomtah1 := Tahy.t[I];
                          pomlongint := HodnotyTahu[I];
                          Tahy.t[I] := Tahy.t[1];
                          HodnotyTahu[I] := HodnotyTahu[1];
                          Tahy.t[1] := pomtah1;
                          HodnotyTahu[1] := pomlongint;
                          if h = Hloubka - 1 then
                            case Styl of
                              Normalni:
                                if HloubkaRekurze <= Vypisovac.Cfg.mnnHloubka
                                then
                                begin
                                  Nejlepsi :=
                                    ' ' + TTah1ToStr(pomtah1, Pozice) + PomStr;
                                end;
                              OnDopredu, JaDopredu:
                                if HloubkaRekurze <= Vypisovac.Cfg.mdnHloubka
                                then
                                begin
                                  Nejlepsi :=
                                    ' ' + TTah1ToStr(pomtah1, Pozice) + PomStr;
                                end;
                            end;
                        end
                      end; { od for cyklu pøes tahy }
                      result := Alfa;
                      if Dojeto then
                        break; { Dopoèítal jsem to a do konce. Zvıšení
                        hloubky propoètu nemá smysl (poèítal bych ji vypoètené). }
                    end { od cyklu pøes hloubku }
                  end { od hb in pozice.stav.b }
                  else { Hraje èernı }
                  begin
                    result := Beta;
                    for h := 0 to Hloubka - 1 do
                    begin
                      { <Ladící vıpisy> }
                      if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
                        (Vypisovac.Cfg.osHloubka > HloubkaRekurze) then
                        if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
                          Vypisovac.Cfg.osDopredu and
                          ((Styl = OnDopredu) or (Styl = JaDopredu)) then
                        begin
                          Vypisovac.writeZacatekAlfaBetaIterace(sAlfa, sBeta, h,
                            HloubkaRekurze)
                        end;
                      { </Ladící vıpisy> }
                      pocitam[0] := AnsiChar(PocPos);
                      Dojeto := true;
                      Alfa := sAlfa;
                      Beta := sBeta;
                      for I := 1 to Tahy.Poctah do
                      begin
                        { <Ladící vıpisy> }
                        if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
                          (Vypisovac.Cfg.osHloubka > HloubkaRekurze) then
                          if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
                            Vypisovac.Cfg.osDopredu and
                            ((Styl = OnDopredu) or (Styl = JaDopredu)) then
                          begin
                            Vypisovac.writeStrOdsaz
                              (TTah1ToStr(Tahy.t[I], Pozice),
                              3 + HloubkaRekurze)
                          end;
                        { </Ladící vıpisy> }
                        { <Bìné vıpisy> }
                        VypisVariantu(Tahy.t[I], pocitam, PocPos, Styl,
                          HloubkaRekurze);
                        { </Bìné vıpisy> }
                        if HodnotyTahu[I] <> NeHodnota then
                        begin
                          PomStr := '';
                          hodnota := HodnotyTahu[I]
                        end
                        { tj. if poèítal bych ji vypoètené, pøeètu si ti z pole }
                        else
                        begin { musím poèítat }
                          DoplnTah(Tahy.t[I], Pozice, t2);
                          tahni(Pozice, Tahy.t[I]);
                          PridejTah(Partie, t2);
                          Dj := true;
                          if PoloRemis(Partie, Pozice) then
                            hodnota := 0
                          else
                          begin
                            PomStr := '';
                            hodnota :=
                              Transformuj(Alfa_Beta(Alfa, Beta, h, Dj,
                              HloubkaRekurze + 1, Styl, pocitam, PomStr));
                          end;
                          UberTah(Partie);
                          if Dj then
                            HodnotyTahu[I] := hodnota
                            { Tah je dopoèítán, zapamatuji si hodnotu }
                          else
                            Dojeto := false; { nedopoèetl-li jsem aspoò 1 tah,
                            je to celé nedopoètené }
                          tahni_zpet(Pozice, t2);
                          if hodnota = NeHodnota then
                          begin
                            result := NeHodnota;
                            pocitam[0] := AnsiChar(PocPos);
                            exit
                          end;
                        end; { od musím poèítat }
                        if hodnota < Beta then
                        begin
                          Beta := hodnota;
                          { <Ladící vıpisy> }
                          if Vypisovac.Cfg.osPovoleno and (Styl <> Nulovy) and
                            (Vypisovac.Cfg.osHloubka > HloubkaRekurze) then
                            if (Styl = Normalni) and Vypisovac.Cfg.osNormalni or
                              Vypisovac.Cfg.osDopredu and
                              ((Styl = OnDopredu) or (Styl = JaDopredu)) then
                            begin
                              Vypisovac.writeStrOdsaz('Zlepšující tah, Beta=' +
                                HodnotaToStr(Beta), 3 + HloubkaRekurze)
                            end;
                          { </Ladící vıpisy> }
                          result := Beta;
                          if Alfa >= Beta then
                            if h = Hloubka - 1 then
                            begin
                              result := Alfa;
                              Dojeto := false;
                              pocitam[0] := AnsiChar(PocPos);
                              exit
                            end
                            else
                              break;
                          pomtah1 := Tahy.t[I];
                          pomlongint := HodnotyTahu[I];
                          Tahy.t[I] := Tahy.t[1];
                          HodnotyTahu[I] := HodnotyTahu[1];
                          Tahy.t[1] := pomtah1;
                          HodnotyTahu[1] := pomlongint;
                          if h = Hloubka - 1 then
                            case Styl of
                              Normalni:
                                if HloubkaRekurze <= Vypisovac.Cfg.mnnHloubka
                                then
                                begin
                                  Nejlepsi :=
                                    ' ' + TTah1ToStr(pomtah1, Pozice) + PomStr;
                                end;
                              OnDopredu, JaDopredu:
                                if HloubkaRekurze <= Vypisovac.Cfg.mdnHloubka
                                then
                                begin
                                  Nejlepsi :=
                                    ' ' + TTah1ToStr(pomtah1, Pozice) + PomStr;
                                end;
                            end;
                        end
                      end; { od for cyklu pøes tahy }
                      result := Beta;

                      if Dojeto then
                        break; { Dopoèítal jsem to a do konce. Zvıšení
                        hloubky propoètu nemá smysl (poèítal bych ji vypoètené). }
                    end; { Od cyklu pøes hloubku }
                  end { Od hraje èernı }
                end { od not(tahy.poctah=0) }
              end { od not(hloubka=0) }
            end; { Od not MusimKoncit }
            pocitam[0] := AnsiChar(PocPos);
          end; { Od Alfa_Beta }

end.
